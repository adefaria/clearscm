#!/usr/local/bin/perl5.8.4
################################################################################
#
# File:         cvsims,v
# Revision:     1.1.1.1
# Author:       Andrew@DeFaria.com
# Description:  This script will read CVS commit information searching for Issue
#		IDs and formulate a "change set" including the files committed
#		and update IMS.
# Created:      Fri Dec  9 15:10:56 PST 2005
# Modified:     2007/05/17 07:45:48
# Language:     perl
#
# (c) Copyright 2005, Andrew@DeFaria.com, all rights reserved
#
################################################################################
use strict;
use warnings;
use File::Spec;

my $me;
my $version = "1.0";

BEGIN {
  # Set $lib_path
  my $lib_path = $^O =~ /MSWin/ ? "\\\\brcm-irv\\dfs\\projects\\ccase\\SCM\\lib"
				: "/projects/ccase/SCM/lib";

  # Extract relative path and basename from script name.
  $0 =~ /(.*)[\/\\](.*)/;

  my $abs_path	= (!defined $1) ? "." : File::Spec->rel2abs ($1);
  $me		= (!defined $2) ? $0  : $2;
  $me		=~ s/\.pl$//;

  # Add the appropriate path to our modules to @INC array.
  unshift @INC, $ENV {SITE_PERL_LIBPATH} if defined $ENV {SITE_PERL_LIBPATH};
  unshift @INC, "$lib_path";
  unshift @INC, "$abs_path";
} # BEGIN

use IMS;
use Display;

sub Usage {
  my $msg = shift;

  display "ERROR: $msg\n" if defined $msg;

  display "Usage: $me\t[-u] [-v] [-d] [-passthru] 
\t\t[{-pre -logfile <filename>} |
\t\t {-post -repository <repository> -path <path>
\t\t  <file> <rev> {<file> <rev>...}}]

Where:

  -u:		 Display usage
  -v:		 Turn on verbose mode
  -d:	 	 Turn on debug mode
  -passthru:	 Passthru stdin to stdout

Pre options:
  -pre:		 Perform pre commit checking.
  -logfile	 Path to logfile containing commit message

Post options:
  -post:	 Perform post commit updating
  -repository:	 Repository (path portion of \$CVSROOT)
  -path:	 Path relative to repository
  <file> <rev>:  Files and revisions commited (Format: \"file rev file rev ...\")
";
  exit 1;
} # Usage

sub UpdateIMS {
  my $issueid		= shift;
  my $repository	= shift;
  my $path		= shift;
  my %filerevs		= @_;

  my $change_set;

  foreach (sort (keys (%filerevs))) {
    $change_set .= "${filerevs {$_}}\t$repository/$path/$_\n";
  } # foreach

  my $error = AddToChangeSet ($issueid, $change_set);

  return $error;
} # UpdateIMS

sub ParseInput {
  my @input = @_;

  my $sentinal = "csp: ";
  my %issue_ids;
  my @issue_ids;
  # Issue id information in the input must have the following format:
  #
  # $sentinal <n>, {n}
  foreach my $line (@input) {
    if ($line =~ /^$sentinal/i) {
      # Remove $sentinal
      $line = substr $line, length ($sentinal);
      # Remove and commas
      $line =~ tr /,/ /;
      @issue_ids = split /\s+/, $line;
      last;
    } # if
  } # foreach

  # Eliminate duplicates on return
  return grep (!$issue_ids {$_}++, @issue_ids);
} # ParseInput

sub ReadFile {
  my $file	= shift;
  my $passthru	= shift;

  my @lines = <$file>;

  my @cleansed_lines;

  foreach (@lines) {
    print $_ if $passthru;
    chomp;
    chop if /\r/;
    push @cleansed_lines, $_ if !/^#/; # Discard comment lines
  } # foreach

  return @cleansed_lines;
} # ReadFile

my $optkind;
my $repository;
my $path;
my $passthru = 0;
my $logfile;
my %filerevs;

while ($ARGV [0]) {
  if ($ARGV [0] eq "-v") {
    Display::set_verbose;
  } elsif ($ARGV [0] eq "-d") {
    set_debug;
  } elsif ($ARGV [0] eq "-passthru") {
    $passthru = 1;
  } elsif ($ARGV [0] eq "-repository") {
    shift @ARGV;
    if (!$ARGV [0]) {
      Usage "Must specify repository after -repository";
    } else {
      $repository = $ARGV [0];
    } # if
  } elsif ($ARGV [0] eq "-path") {
    shift @ARGV;
    if (!$ARGV [0]) {
      Usage "Must specify path after -path";
    } else {
      $path = $ARGV [0];
    } # if
  } elsif ($ARGV [0] eq "-pre") {
    $optkind = "pre";
  } elsif ($ARGV [0] eq "-logfile") {
    shift @ARGV;
    if (!$ARGV [0]) {
      Usage "Must specify log filename after -logfile";
    } else {
      $logfile = $ARGV [0];
    } # if
  } elsif ($ARGV [0] eq "-post") {
    $optkind = "post";
  } elsif ($ARGV [0] eq "-u") {
    Usage;
  } else {
    %filerevs = @ARGV;
    last;
  } # if

  shift (@ARGV);
} # while

Usage "Must specify -pre or -post" if !defined $optkind;

if ($optkind eq "pre") {
  Usage "No logfile to parse" if !defined $logfile;
} elsif ($optkind eq "post") {
  Usage "No files committed" if !%filerevs;
} # if

my @issue_ids;

if ($optkind eq "pre") {
  verbose "$me v$version: Checking for Issue ID(s)...";
  open LOGFILE, $logfile
    or error "Unable to open logfile $logfile - $!", 4;

  @issue_ids = ParseInput ReadFile (*LOGFILE);

  close LOGFILE;
} else {
  # Special case here. Seems cvs will call this script through loginfo
  # even though directories are not versioned in cvs. If so then
  # %filerevs will contain "- New directory" and "NONE". In this case
  # we simply exit 0.
  if (defined $filerevs {"- New directory"}) {
    exit 0;
  } # if

  verbose "$me v$version: Updating Issue ID(s)...";
  @issue_ids = ParseInput ReadFile (*STDIN, $passthru);
} # if

if (scalar (@issue_ids) eq 0) {
  error "No issue ID(s) found", 1;
} # if

verbose "Verifying Issue IDs";

foreach (@issue_ids) {
  my %issue_info = GetIssue $_;

  if (%issue_info) {
    verbose "Issue $_ exists in IMS";
  } else {
    error "Issue ID $_ does not exist in IMS", 2 if !%issue_info;
  } # if
} # foreach

if ($optkind eq "post") {
  foreach my $issue_id (@issue_ids) {
    verbose "Updating Issue ID ${issue_id}'s Change Set";

    my $error = UpdateIMS $issue_id, $repository, $path, %filerevs;

    if ($error ne "") {
      error $error, 3;
    } else {
      verbose "Issue ID ${issue_id}'s Change Set updated";
    } # if
  } # foreach
} # if

exit 0;
